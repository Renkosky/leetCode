# 回溯算法

回溯算法实际上一个类似枚举的深度优先搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。

三元素：
1、选择。对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个 if 或者 for 循环来排列。

2、条件。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。
3、结束。当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个 issolution 函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。

对于回溯法来说，每次递归调用，很重要的一点是把每次递归的不同信息传递给递归调用的函数。而这里最重要的要传递给递归调用函数的信息，就是把上一步做过的某些事情的这个选择排除，避免重复和无限递归。另外还有一个信息必须传递给递归函数，就是进行了每一步选择后，暂时还没构成完整的解，这个时候前面所有选择的汇总也要传递进去。而且一般情况下，都是能从传递给递归函数的参数处，得到结束条件的。

### 递归函数的参数的选择，要遵循四个原则：

1、必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。
2、可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。
3、最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量 n，也许是数组的长度，也许是数量，等等。
4、要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。

### 例题

一、给出 n 对括号，求括号排列的所有可能性。
因为括号必定成队出现，所以共有 n 个左括号和 n 个右括号
r,l 代表剩余要分配的左右括号个数
1、选择。
解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号；

2、条件
在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于 0 才能放入左括号。这里 if 的顺序会影响输出的顺序，但是不影响最终解；
r>l 左括号分配过，该右括号分配
l>0 左括号还有没分配的
3、结束。
l+r====0 分配完了

```javascript
var generateParenthesis = function(n) {
  var res = []
  backtrade(n, n, res, '')
  return res
}
function backtrade(l, r, res, sublist) {
  if (l + r === 0) {
    res.push(sublist)
  }
  if (r > l) {
    backtrade(l, r - 1, res, sublist + ')')
  }
  if (l > 0) {
    backtrade(l - 1, r, res, sublist + '(')
  }
}
```
